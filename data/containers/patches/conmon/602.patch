From c4e6532d27e7d1a0dccca616d59e929139861dbb Mon Sep 17 00:00:00 2001
From: Jan Kaluza <jkaluza@redhat.com>
Date: Tue, 16 Sep 2025 15:57:10 +0200
Subject: [PATCH] Add more tests for --stdin and --exec.

This commit adds few tests for --stdin and --exec and also moves
some common functions from 04-runtime.bats to test-helpers.bash.

Signed-off-by: Jan Kaluza <jkaluza@redhat.com>
---
 test/04-runtime.bats  |  43 --------------
 test/07-attach.bats   |  56 +++++++++++++++++++
 test/08-exec.bats     |  45 +++++++++++++++
 test/test_helper.bash | 127 +++++++++++++++++++++++++++++++++++++++++-
 4 files changed, 225 insertions(+), 46 deletions(-)
 create mode 100644 test/07-attach.bats
 create mode 100644 test/08-exec.bats

diff --git a/test/04-runtime.bats b/test/04-runtime.bats
index f4baee6b..311ac703 100644
--- a/test/04-runtime.bats
+++ b/test/04-runtime.bats
@@ -12,49 +12,6 @@ teardown() {
     cleanup_test_env
 }
 
-# Helper function to wait until "runc state $cid" returns expected status.
-wait_for_runtime_status() {
-    local cid=$1
-    local expected_status=$2
-    local how_long=5
-
-    t1=$(expr $SECONDS + $how_long)
-    while [ $SECONDS -lt $t1 ]; do
-        run_runtime state "$cid"
-        echo "$output"
-        if expr "$output" : ".*status\": \"$expected_status"; then
-            return
-        fi
-        sleep 0.5
-    done
-
-    die "timed out waiting for '$expected_status' from $cid"
-}
-
-# Helper function to run conmon with basic options
-run_conmon_with_default_args() {
-    local extra_args=("$@")
-    timeout 30s "$CONMON_BINARY" \
-        --cid "$CTR_ID" \
-        --cuuid "$CTR_ID" \
-        --runtime "$RUNTIME_BINARY" \
-        --bundle "$BUNDLE_PATH" \
-        --socket-dir-path "$SOCKET_PATH" \
-        --log-level trace \
-        --container-pidfile "$PID_FILE" \
-        --conmon-pidfile "$CONMON_PID_FILE" "${extra_args[@]}"
-
-    # Wait until the container is created
-    wait_for_runtime_status "$CTR_ID" created
-
-    # Check that conmon pidfile was created
-    [ -f "$CONMON_PID_FILE" ]
-
-    # Start the container and wait until it is stopped.
-    run_runtime start "$CTR_ID"
-    wait_for_runtime_status "$CTR_ID" stopped
-}
-
 @test "runtime: simple runtime test" {
     run_conmon_with_default_args --log-path "k8s-file:$LOG_PATH"
 
diff --git a/test/07-attach.bats b/test/07-attach.bats
new file mode 100644
index 00000000..f40638bc
--- /dev/null
+++ b/test/07-attach.bats
@@ -0,0 +1,56 @@
+#!/usr/bin/env bats
+
+load test_helper
+
+setup() {
+    check_conmon_binary
+    check_runtime_binary
+    setup_container_env "/busybox cat && echo 'Container stopped!'"
+}
+
+teardown() {
+    cleanup_test_env
+}
+
+@test "attach: attach to container and send string to stdin" {
+    start_conmon_with_default_args --log-path "k8s-file:$LOG_PATH" --stdin
+    wait_for_runtime_status "$CTR_ID" running
+    echo "Hello there!" | socat STDIN "UNIX:${ATTACH_PATH},socktype=5"
+
+    # Check that log file was created
+    assert_file_exists "$LOG_PATH"
+    run cat "$LOG_PATH"
+    assert "${output}" =~ "Hello there!"  "'Hello there!' found in the log"
+    assert "${output}" =~ "Container stopped!"  "'Container stopped!' found in the log"
+
+    assert_file_not_exists "$ATTACH_PATH"
+}
+
+@test "attach: container finishes immediately without --stdin" {
+    # Pipe is closed without --stdin, so `/cat` does not hang indefinitely, but finishes.
+    start_conmon_with_default_args --log-path "k8s-file:$LOG_PATH"
+    wait_for_runtime_status "$CTR_ID" stopped
+
+    # Check that log file was created
+    assert_file_exists "$LOG_PATH"
+    run cat "$LOG_PATH"
+    assert "${output}" =~ "Container stopped!"  "'Container stopped!' found in the log"
+}
+
+@test "attach: unix socket remains open with --leave-stdin-open" {
+    start_conmon_with_default_args --log-path "k8s-file:$LOG_PATH" --stdin --leave-stdin-open
+    wait_for_runtime_status "$CTR_ID" running
+    echo "Hello there!" | socat STDIN "UNIX:${ATTACH_PATH},socktype=5"
+
+    # Check that log file was created
+    assert_file_exists "$LOG_PATH"
+    run cat "$LOG_PATH"
+    assert "${output}" =~ "Hello there!"  "'Hello there!' found in the log"
+    assert "${output}" !~ "Container stopped!"  "'Container stopped!' not found in the log"
+
+    assert_file_exists "$ATTACH_PATH"
+    echo "Hello there again!" | socat STDIN "UNIX:${ATTACH_PATH},socktype=5"
+    run cat "$LOG_PATH"
+    assert "${output}" =~ "Hello there again!"  "'Hello there again!' found in the log"
+    assert "${output}" !~ "Container stopped!"  "'Container stopped!' not found in the log"
+}
diff --git a/test/08-exec.bats b/test/08-exec.bats
new file mode 100644
index 00000000..22993e58
--- /dev/null
+++ b/test/08-exec.bats
@@ -0,0 +1,45 @@
+#!/usr/bin/env bats
+
+load test_helper
+
+setup() {
+    check_conmon_binary
+    check_runtime_binary
+    setup_container_env "while [ ! -f /tmp/test.txt ]; do /busybox sleep 0.1; done; /busybox cat /tmp/test.txt"
+}
+
+teardown() {
+    cleanup_test_env
+}
+
+@test "exec: simple --exec --exec-process-spec" {
+    generate_process_spec "echo 'Hello from exec!' && /busybox echo 'Hello there!' > /tmp/test.txt"
+    start_conmon_with_default_args --log-path "k8s-file:$LOG_PATH"
+    wait_for_runtime_status "$CTR_ID" running
+
+    timeout 2s "$CONMON_BINARY" \
+        --cid "$CTR_ID" \
+        --cuuid "$CTR_ID" \
+        --runtime "$RUNTIME_BINARY" \
+        --bundle "$BUNDLE_PATH" \
+        --socket-dir-path "$SOCKET_PATH" \
+        --log-level trace \
+        --container-pidfile "$PID_FILE" \
+        --syslog \
+        --conmon-pidfile "$CONMON_PID_FILE" \
+        --log-path "k8s-file:$LOG_PATH.exec" \
+        --exec \
+        --exec-process-spec "${BUNDLE_PATH}/process.json"
+
+    wait_for_runtime_status "$CTR_ID" stopped
+
+    # Check that the main process noticed the /tmp/test.txt.
+    assert_file_exists "$LOG_PATH"
+    run cat "$LOG_PATH"
+    assert "${output}" =~ "Hello there!"  "'Hello there!' found in the log"
+
+    # Check that the exec process output is stored in the log.
+    assert_file_exists "$LOG_PATH.exec"
+    run cat "$LOG_PATH.exec"
+    assert "${output}" =~ "Hello from exec!"  "'Hello from exec!' found in the log"
+}
diff --git a/test/test_helper.bash b/test/test_helper.bash
index f08ad1fa..8b02d39f 100644
--- a/test/test_helper.bash
+++ b/test/test_helper.bash
@@ -95,10 +95,62 @@ cleanup_tmpdir() {
     fi
 }
 
+# Generate process.json
+generate_process_spec() {
+    local command="$1"
+    if [[ -z "$command" ]]; then
+        command="for i in \$(/busybox seq 1 100); do /busybox echo \\\"hello from busybox \$i\\\"; done"
+    fi
+    if [[ -z "$BUNDLE_PATH" || ! -e "$BUNDLE_PATH" ]]; then
+        die "The BUNDLE_PATH directory does not exist. Ensure 'generate_process_spec'" \
+        " is called after the 'setup_test_env'"
+    fi
+    local config_path="$BUNDLE_PATH/process.json"
+
+    cat > "$config_path" << EOF
+{
+    "terminal": false,
+    "user": {
+        "uid": 0,
+        "gid": 0
+    },
+    "args": [
+        "/busybox",
+        "sh",
+        "-c",
+        "$command"
+    ],
+    "env": [
+        "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
+    ],
+    "cwd": "/",
+    "capabilities": {
+        "bounding": [],
+        "effective": [],
+        "inheritable": [],
+        "permitted": [],
+        "ambient": []
+    },
+    "rlimits": [
+        {
+            "type": "RLIMIT_NOFILE",
+            "hard": 1024,
+            "soft": 1024
+        }
+    ],
+    "noNewPrivileges": true
+}
+EOF
+}
+
 # Generate OCI runtime configuration
 generate_runtime_config() {
     local bundle_path="$1"
     local rootfs="$2"
+    local command="$3"
+    if [[ -z "$command" ]]; then
+        command="for i in \$(/busybox seq 1 100); do /busybox echo \\\"hello from busybox \$i\\\"; done"
+    fi
     local config_path="$bundle_path/config.json"
 
     # Make rootfs path relative to bundle
@@ -123,7 +175,7 @@ generate_runtime_config() {
             "/busybox",
             "sh",
             "-c",
-            "for i in \$(/busybox seq 1 100); do /busybox echo \"hello from busybox \$i\"; done"
+            "$command"
         ],
         "env": [
             "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
@@ -242,10 +294,12 @@ setup_test_env() {
     export BUNDLE_PATH="$TEST_TMPDIR"
     export ROOTFS="$TEST_TMPDIR/rootfs"
     export SOCKET_PATH="$TEST_TMPDIR"
+    export ATTACH_PATH="$TEST_TMPDIR/attach"
 }
 
 # Setup full container environment with busybox
 setup_container_env() {
+    local command="$1"
     setup_test_env
 
     # Cache busybox binary for container tests
@@ -269,7 +323,7 @@ setup_container_env() {
     echo "root:x:0:" > "$ROOTFS/etc/group"
 
     # Generate OCI runtime configuration
-    generate_runtime_config "$BUNDLE_PATH" "$ROOTFS"
+    generate_runtime_config "$BUNDLE_PATH" "$ROOTFS" "$command"
 }
 
 # Cleanup test environment
@@ -315,9 +369,76 @@ assert_stderr_contains() {
     fi
 }
 
+# Helper function to wait until "runc state $cid" returns expected status.
+wait_for_runtime_status() {
+    local cid=$1
+    local expected_status=$2
+    local how_long=5
+
+    t1=$(expr $SECONDS + $how_long)
+    while [ $SECONDS -lt $t1 ]; do
+        run_runtime state "$cid"
+        echo "$output"
+        if expr "$output" : ".*status\": \"$expected_status"; then
+            return
+        fi
+        sleep 0.5
+    done
+
+    die "timed out waiting for '$expected_status' from $cid"
+}
+
+# Helper function to start conmon with default arguments.
+# Additional conmon arguments can be passed to this function.
+start_conmon_with_default_args() {
+    local extra_args=("$@")
+    timeout 10s "$CONMON_BINARY" \
+        --cid "$CTR_ID" \
+        --cuuid "$CTR_ID" \
+        --runtime "$RUNTIME_BINARY" \
+        --bundle "$BUNDLE_PATH" \
+        --socket-dir-path "$SOCKET_PATH" \
+        --log-level trace \
+        --container-pidfile "$PID_FILE" \
+        --syslog \
+        --conmon-pidfile "$CONMON_PID_FILE" "${extra_args[@]}"
+
+    # Wait until the container is created
+    wait_for_runtime_status "$CTR_ID" created
+
+    # Check that conmon pidfile was created
+    [ -f "$CONMON_PID_FILE" ]
+
+    # Start the container and wait until it really starts.
+    run_runtime start "$CTR_ID"
+}
+
+# Helper function to run conmon with default arguments and wait until it is stopped.
+# Additional conmon arguments can be passed to this function.
+run_conmon_with_default_args() {
+    start_conmon_with_default_args "$@"
+    wait_for_runtime_status "$CTR_ID" stopped
+}
+
+# Helper function ensuring the file does not exist.
+assert_file_not_exists() {
+    FILE=$1
+    if [ -e "$FILE" ]; then
+        die "$(date): File $FILE exists."
+    fi
+}
+
+# Helper function ensuring the file does exist.
+assert_file_exists() {
+    FILE=$1
+    if [ ! -e "$FILE" ]; then
+        die "$(date): File $FILE does not exist."
+    fi
+}
+
 # bail-now is how we terminate a test upon assertion failure.
 # By default, and the vast majority of the time, it just triggers
-# immediate test termination; but see defer-assertion-failures, below.
+# immediate test termination;
 function bail-now() {
     # "false" does not apply to "bail now"! It means "nonzero exit",
     # which BATS interprets as "yes, bail immediately".
