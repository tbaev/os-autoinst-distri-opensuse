From 06c09235f0fc1d5117d86a0cdad886de450428ac Mon Sep 17 00:00:00 2001
From: Jan Kaluza <jkaluza@redhat.com>
Date: Fri, 12 Sep 2025 15:09:40 +0200
Subject: [PATCH] Really run the container in the 04-runtime.bats.

Previously, the conmon has been tested in the 04-runtime.bats, but
we never tried to really run the container defined by the conmon.
It was therefore not clear whether the conmon configure the runc
correctly and whether the logs are really forwarded where they should
be.

This commit changes it by running the `runc start`. The `sleep` based
waiting login is replaced by polling of `runc state` to detect the
container `created` and `stopped` states - this makes tests faster
and more reliable.

The `assert` helper method to compare strings is borrowed from
the podman project as it is.

The `container cleanup on completion` test is removed, since it does
not test anything not tested by the previous tests.

Signed-off-by: Jan Kaluza <jkaluza@redhat.com>
---
 .cirrus.yml           |   5 +-
 test/04-runtime.bats  | 156 ++++++++++++++----------------------------
 test/test_helper.bash | 140 ++++++++++++++++++++++++++++++++++++-
 3 files changed, 191 insertions(+), 110 deletions(-)

diff --git a/.cirrus.yml b/.cirrus.yml
index 27cea4fd..532a060e 100644
--- a/.cirrus.yml
+++ b/.cirrus.yml
@@ -77,10 +77,11 @@ fedora_packaging_task:
 # Verify build completes successfully
 build_task:
     # Runs within Cirrus's "community cluster"
-    container:
-        image: "${FEDORA_CONTAINER_FQIN}"
+    gce_instance:
+        image_name: "${FEDORA_CACHE_IMAGE_NAME}"
         cpu: 1
         memory: 4
+        disk: 200
 
     script:
         - dnf install -y make glib2-devel git gcc pkg-config systemd-devel libseccomp-devel
diff --git a/test/04-runtime.bats b/test/04-runtime.bats
index 71400026..f4baee6b 100644
--- a/test/04-runtime.bats
+++ b/test/04-runtime.bats
@@ -12,146 +12,92 @@ teardown() {
     cleanup_test_env
 }
 
-@test "runtime: simple runtime test" {
-    # Run conmon which will create and manage the container
-    # Using a timeout to prevent hanging
+# Helper function to wait until "runc state $cid" returns expected status.
+wait_for_runtime_status() {
+    local cid=$1
+    local expected_status=$2
+    local how_long=5
+
+    t1=$(expr $SECONDS + $how_long)
+    while [ $SECONDS -lt $t1 ]; do
+        run_runtime state "$cid"
+        echo "$output"
+        if expr "$output" : ".*status\": \"$expected_status"; then
+            return
+        fi
+        sleep 0.5
+    done
+
+    die "timed out waiting for '$expected_status' from $cid"
+}
+
+# Helper function to run conmon with basic options
+run_conmon_with_default_args() {
+    local extra_args=("$@")
     timeout 30s "$CONMON_BINARY" \
         --cid "$CTR_ID" \
         --cuuid "$CTR_ID" \
         --runtime "$RUNTIME_BINARY" \
-        --log-path "k8s-file:$LOG_PATH" \
         --bundle "$BUNDLE_PATH" \
         --socket-dir-path "$SOCKET_PATH" \
-        --log-level debug \
+        --log-level trace \
         --container-pidfile "$PID_FILE" \
-        --conmon-pidfile "$CONMON_PID_FILE" &
+        --conmon-pidfile "$CONMON_PID_FILE" "${extra_args[@]}"
 
-    local conmon_pid=$!
+    # Wait until the container is created
+    wait_for_runtime_status "$CTR_ID" created
 
-    # Give conmon time to start up and run the container
-    sleep 2
+    # Check that conmon pidfile was created
+    [ -f "$CONMON_PID_FILE" ]
+
+    # Start the container and wait until it is stopped.
+    run_runtime start "$CTR_ID"
+    wait_for_runtime_status "$CTR_ID" stopped
+}
 
-    # Check if conmon is still running or completed
-    if kill -0 $conmon_pid 2>/dev/null; then
-        # Kill conmon if it's still running
-        kill $conmon_pid 2>/dev/null || true
-        wait $conmon_pid 2>/dev/null || true
-    fi
+@test "runtime: simple runtime test" {
+    run_conmon_with_default_args --log-path "k8s-file:$LOG_PATH"
 
     # Check that log file was created
     [ -f "$LOG_PATH" ]
-
-    # Check that conmon pidfile was created
-    [ -f "$CONMON_PID_FILE" ]
+    run cat "$LOG_PATH"
+    assert "${output}" =~ "hello from busybox"  "'hello from busybox' found in the log"
 }
 
 @test "runtime: container execution with different log drivers" {
     # Test with journald log driver
-    timeout 30s "$CONMON_BINARY" \
-        --cid "$CTR_ID" \
-        --cuuid "$CTR_ID" \
-        --runtime "$RUNTIME_BINARY" \
-        --log-path "journald:" \
-        --bundle "$BUNDLE_PATH" \
-        --socket-dir-path "$SOCKET_PATH" \
-        --container-pidfile "$PID_FILE" \
-        --conmon-pidfile "$CONMON_PID_FILE" &
-
-    local conmon_pid=$!
-    sleep 2
-
-    if kill -0 $conmon_pid 2>/dev/null; then
-        kill $conmon_pid 2>/dev/null || true
-        wait $conmon_pid 2>/dev/null || true
-    fi
+    run_conmon_with_default_args --log-path "journald:"
 
-    # Check that conmon pidfile was created
-    [ -f "$CONMON_PID_FILE" ]
+    run journalctl --user CONTAINER_ID_FULL="$CTR_ID"
+    assert "${output}" =~ "hello from busybox"  "'hello from busybox' found in the journald"
 }
 
 @test "runtime: container execution with multiple log drivers" {
     # Test with both k8s-file and journald log drivers
-    timeout 30s "$CONMON_BINARY" \
-        --cid "$CTR_ID" \
-        --cuuid "$CTR_ID" \
-        --runtime "$RUNTIME_BINARY" \
-        --log-path "k8s-file:$LOG_PATH" \
-        --log-path "journald:" \
-        --bundle "$BUNDLE_PATH" \
-        --socket-dir-path "$SOCKET_PATH" \
-        --container-pidfile "$PID_FILE" \
-        --conmon-pidfile "$CONMON_PID_FILE" &
-
-    local conmon_pid=$!
-    sleep 2
-
-    if kill -0 $conmon_pid 2>/dev/null; then
-        kill $conmon_pid 2>/dev/null || true
-        wait $conmon_pid 2>/dev/null || true
-    fi
+    run_conmon_with_default_args --log-path "k8s-file:$LOG_PATH" --log-path "journald:"
 
     # Check that log file was created
     [ -f "$LOG_PATH" ]
 
-    # Check that conmon pidfile was created
-    [ -f "$CONMON_PID_FILE" ]
+    run cat "$LOG_PATH"
+    assert "${output}" =~ "hello from busybox"  "'hello from busybox' found in the log"
+
+    run journalctl --user CONTAINER_ID_FULL="$CTR_ID"
+    assert "${output}" =~ "hello from busybox"  "'hello from busybox' found in the journald"
 }
 
 @test "runtime: container with log size limit" {
     # Test container execution with log rotation
-    local log_size_max=1024
+    # This effectively keeps just the last line at max.
+    local log_size_max=10
 
-    timeout 30s "$CONMON_BINARY" \
-        --cid "$CTR_ID" \
-        --cuuid "$CTR_ID" \
-        --runtime "$RUNTIME_BINARY" \
-        --log-path "k8s-file:$LOG_PATH" \
-        --log-size-max "$log_size_max" \
-        --bundle "$BUNDLE_PATH" \
-        --socket-dir-path "$SOCKET_PATH" \
-        --container-pidfile "$PID_FILE" \
-        --conmon-pidfile "$CONMON_PID_FILE" &
-
-    local conmon_pid=$!
-    sleep 2
-
-    if kill -0 $conmon_pid 2>/dev/null; then
-        kill $conmon_pid 2>/dev/null || true
-        wait $conmon_pid 2>/dev/null || true
-    fi
+    run_conmon_with_default_args --log-path "k8s-file:$LOG_PATH" --log-size-max "$log_size_max"
 
     # Check that log file was created
     [ -f "$LOG_PATH" ]
 
-    # Check that conmon pidfile was created
-    [ -f "$CONMON_PID_FILE" ]
-}
-
-@test "runtime: container cleanup on completion" {
-    # Create and run a container, then verify cleanup
-    timeout 30s "$CONMON_BINARY" \
-        --cid "$CTR_ID" \
-        --cuuid "$CTR_ID" \
-        --runtime "$RUNTIME_BINARY" \
-        --log-path "k8s-file:$LOG_PATH" \
-        --bundle "$BUNDLE_PATH" \
-        --socket-dir-path "$SOCKET_PATH" \
-        --container-pidfile "$PID_FILE" \
-        --conmon-pidfile "$CONMON_PID_FILE" &
-
-    local conmon_pid=$!
-    sleep 2
-
-    if kill -0 $conmon_pid 2>/dev/null; then
-        kill $conmon_pid 2>/dev/null || true
-        wait $conmon_pid 2>/dev/null || true
-    fi
-
-    # Check that log file was created
-    [ -f "$LOG_PATH" ]
-
-    # Check that conmon pidfile was created
-    [ -f "$CONMON_PID_FILE" ]
+    run cat "$LOG_PATH"
+    assert "${output}" !~ "hello from busybox 11"  "'hello from busybox 11' not in the logs"
 }
 
 @test "runtime: invalid runtime binary should fail" {
diff --git a/test/test_helper.bash b/test/test_helper.bash
index c33665e3..f08ad1fa 100644
--- a/test/test_helper.bash
+++ b/test/test_helper.bash
@@ -121,8 +121,9 @@ generate_runtime_config() {
         },
         "args": [
             "/busybox",
-            "echo",
-            "busybox"
+            "sh",
+            "-c",
+            "for i in \$(/busybox seq 1 100); do /busybox echo \"hello from busybox \$i\"; done"
         ],
         "env": [
             "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
@@ -312,4 +313,137 @@ assert_stderr_contains() {
         echo "Actual stderr: $stderr"
         return 1
     fi
-}
\ No newline at end of file
+}
+
+# bail-now is how we terminate a test upon assertion failure.
+# By default, and the vast majority of the time, it just triggers
+# immediate test termination; but see defer-assertion-failures, below.
+function bail-now() {
+    # "false" does not apply to "bail now"! It means "nonzero exit",
+    # which BATS interprets as "yes, bail immediately".
+    false
+}
+
+############
+#  assert  #  Compare actual vs expected string; fail if mismatch
+############
+#
+# Compares string (default: $output) against the given string argument.
+# By default we do an exact-match comparison against $output, but there
+# are two different ways to invoke us, each with an optional description:
+#
+#      assert               "EXPECT" [DESCRIPTION]
+#      assert "RESULT" "OP" "EXPECT" [DESCRIPTION]
+#
+# The first form (one or two arguments) does an exact-match comparison
+# of "$output" against "EXPECT". The second (three or four args) compares
+# the first parameter against EXPECT, using the given OPerator. If present,
+# DESCRIPTION will be displayed on test failure.
+#
+# Examples:
+#
+#   assert "this is exactly what we expect"
+#   assert "${lines[0]}" =~ "^abc"  "first line begins with abc"
+#
+function assert() {
+    local actual_string="$output"
+    local operator='=='
+    local expect_string="$1"
+    local testname="$2"
+
+    case "${#*}" in
+        0)   die "Internal error: 'assert' requires one or more arguments" ;;
+        1|2) ;;
+        3|4) actual_string="$1"
+             operator="$2"
+             expect_string="$3"
+             testname="$4"
+             ;;
+        *)   die "Internal error: too many arguments to 'assert'" ;;
+    esac
+
+    # Comparisons.
+    # Special case: there is no !~ operator, so fake it via '! x =~ y'
+    local not=
+    local actual_op="$operator"
+    if [[ $operator == '!~' ]]; then
+        not='!'
+        actual_op='=~'
+    fi
+    if [[ $operator == '=' || $operator == '==' ]]; then
+        # Special case: we can't use '=' or '==' inside [[ ... ]] because
+        # the right-hand side is treated as a pattern... and '[xy]' will
+        # not compare literally. There seems to be no way to turn that off.
+        if [ "$actual_string" = "$expect_string" ]; then
+            return
+        fi
+    elif [[ $operator == '!=' ]]; then
+        # Same special case as above
+        if [ "$actual_string" != "$expect_string" ]; then
+            return
+        fi
+    else
+        if eval "[[ $not \$actual_string $actual_op \$expect_string ]]"; then
+            return
+        elif [ $? -gt 1 ]; then
+            die "Internal error: could not process 'actual' $operator 'expect'"
+        fi
+    fi
+
+    # Test has failed. Get a descriptive test name.
+    if [ -z "$testname" ]; then
+        testname="${MOST_RECENT_PODMAN_COMMAND:-[no test name given]}"
+    fi
+
+    # Display optimization: the typical case for 'expect' is an
+    # exact match ('='), but there are also '=~' or '!~' or '-ge'
+    # and the like. Omit the '=' but show the others; and always
+    # align subsequent output lines for ease of comparison.
+    local op=''
+    local ws=''
+    if [ "$operator" != '==' ]; then
+        op="$operator "
+        ws=$(printf "%*s" ${#op} "")
+    fi
+
+    # This is a multi-line message, which may in turn contain multi-line
+    # output, so let's format it ourself to make it more readable.
+    local expect_split
+    mapfile -t expect_split <<<"$expect_string"
+    local actual_split
+    mapfile -t actual_split <<<"$actual_string"
+
+    # bash %q is really nice, except for the way it backslashes spaces
+    local -a expect_split_q
+    for line in "${expect_split[@]}"; do
+        local q=$(printf "%q" "$line" | sed -e 's/\\ / /g')
+        expect_split_q+=("$q")
+    done
+    local -a actual_split_q
+    for line in "${actual_split[@]}"; do
+        local q=$(printf "%q" "$line" | sed -e 's/\\ / /g')
+        actual_split_q+=("$q")
+    done
+
+    printf "#/vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n"    >&2
+    printf "#|     FAIL: %s\n" "$testname"                        >&2
+    printf "#| expected: %s%s\n" "$op" "${expect_split_q[0]}"     >&2
+    local line
+    for line in "${expect_split_q[@]:1}"; do
+        printf "#|         > %s%s\n" "$ws" "$line"                >&2
+    done
+    printf "#|   actual: %s%s\n" "$ws" "${actual_split_q[0]}"     >&2
+    for line in "${actual_split_q[@]:1}"; do
+        printf "#|         > %s%s\n" "$ws" "$line"                >&2
+    done
+    printf "#\\^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"   >&2
+    bail-now
+}
+
+function die() {
+    # FIXME: handle multi-line output
+    echo "#/vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"  >&2
+    echo "#| FAIL: $*"                                           >&2
+    echo "#\\^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^" >&2
+    bail-now
+}
